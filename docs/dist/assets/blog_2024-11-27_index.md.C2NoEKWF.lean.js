import{_ as a,c as t,a1 as s,o as n}from"./chunks/framework.GKu-Ijuu.js";const o="/assets/danfe_addition_example.CJGdDzFY.png",r="/mascot/hmmm.png",u=JSON.parse('{"title":"Danfe is slow?","description":"","frontmatter":{"title":"Danfe is slow?","date":"2024-11-27T00:00:00.000Z"},"headers":[],"relativePath":"blog/2024-11-27/index.md","filePath":"blog/2024-11-27/index.md"}'),i={name:"blog/2024-11-27/index.md"};function l(p,e,c,h,d,g){return n(),t("div",null,e[0]||(e[0]=[s(`<h1 id="danfe-is-slow" tabindex="-1">Danfe is slow? <a class="header-anchor" href="#danfe-is-slow" aria-label="Permalink to &quot;Danfe is slow?&quot;">‚Äã</a></h1><p><a href="/blog">&lt;- Back to blogs</a></p><p><strong>Building My Own Programming Language: Progress, Challenges, and Future Plans</strong></p><p>For the past month, I&#39;ve been working on creating my own programming language, and it‚Äôs finally reaching a stage I‚Äôd call ‚Äúmature.‚Äù By mature, I mean the language now supports core functionality such as creating, updating, deleting, and reading variables. It handles six data types: <strong>string</strong>, <strong>int</strong>, <strong>float</strong>, <strong>table</strong>, <strong>function</strong>, and variables are scoped properly.</p><p>However, there&#39;s a significant hurdle I&#39;ve encountered and that is called performance issues with the interpreter. Here&#39;s the root of the problem.</p><hr><p><strong>Understanding the Problem: The Variable Tracker Map</strong></p><p>My interpreter relies heavily on a map (or a dictionary) to track variables.</p><div class="info custom-block"><p class="custom-block-title">INFO</p><p>What is a map?</p><p>A map is like a key-value database where each variable has a unique key, and its associated value is stored and retrieved using this key.</p></div><p>You might wonder what‚Äôs the issue here? Well, the problem lies in how frequently the interpreter accesses this map. Every operation in my language requires the interpreter to look up the variable in the map using its scope-specific key. For small programs, this is manageable, but for larger ones, the overhead becomes substantial.</p><p>For example, consider the following code snippet in <strong>danfe</strong>:</p><div class="language-danfe vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">danfe</span><pre class="shiki github-dark-high-contrast" style="background-color:#0a0c10;color:#f0f3f6;" tabindex="0"><code><span class="line"><span style="color:#FFB757;">x</span><span style="color:#FF9492;"> =</span><span style="color:#91CBFF;"> 0</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">for</span><span style="color:#F0F3F6;"> x </span><span style="color:#FF9492;">&lt;</span><span style="color:#FFB1AF;font-style:italic;"> 10_000_000</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FFB757;">    x</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> x </span><span style="color:#FF9492;">+</span><span style="color:#91CBFF;"> 1</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span></code></pre></div><p>This code simply increments a variable x 10 million times. But here‚Äôs the catch: executing this loop takes 2 minutes and 4 seconds. üòü Why? Let‚Äôs break it down.</p><hr><p><strong>The Cost of Variable Tracking: Analyzing the Bottleneck</strong></p><p>Here‚Äôs what happens during each iteration of the loop:</p><ul><li>The interpreter fetches x from the map to check the condition (x &lt; 10_000_000).</li><li>It fetches x again to calculate the new value (x = x + 1).</li><li>It stores the updated value of x back into the map.</li></ul><p>In total, the variable tracker map is accessed 5 times per iteration. Multiply that by 10 million iterations, and the map is accessed 50 million times for this single loop. That‚Äôs a massive performance hit!</p><hr><p><strong>Visualizing the Problem</strong></p><p>To make it easier to understand, here‚Äôs a visual representation of what happens during each iteration:</p><p><img src="`+o+'" alt="visualize"></p><p>Notice how frequently the variable tracker is called for what seems like a simple operation. This inefficiency becomes a performance bottleneck for larger programs.</p><hr><p><strong>What‚Äôs Next? Solving the Problem</strong></p><p>You‚Äôre probably wondering what steps I‚Äôve taken to address this issue. As of now, I haven‚Äôt implemented a solution yet. My current plan is to compile danfe into another, more mature programming language. By doing this, I can offload the performance-heavy tasks to a more optimized runtime environment and bypass the inefficiencies of my current interpreter.</p><p>Will this approach work? Only time will tell. how this experiment evolves!</p><p><span style="color:gray;font-size:14px;">Date: 2024-11-27</span><img src="'+r+'" style="height:170px;position:absolute;right:0;"></p>',28)]))}const f=a(i,[["render",l]]);export{u as __pageData,f as default};
